[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Angel Feliz",
    "section": "",
    "text": "Senior Reporting Analyst with 2 years’ experience using R to process and create business reports in formats as Excel, Word, Power Point, and html.\nProven experience integrating ad hoc regular expressions to transform, extract and validate text data in data pipelines to find abnormalities and automate repetitive tasks; improving reporting accuracy, reducing waiting times and opening new possibilities to empower decision makers.\nAutodidactic, self-motivated, inquisitive, and eager to apply data science techniques to create business value and increase ROI for your company"
  },
  {
    "objectID": "index.html#bio",
    "href": "index.html#bio",
    "title": "Angel Feliz",
    "section": "",
    "text": "Senior Reporting Analyst with 2 years’ experience using R to process and create business reports in formats as Excel, Word, Power Point, and html.\nProven experience integrating ad hoc regular expressions to transform, extract and validate text data in data pipelines to find abnormalities and automate repetitive tasks; improving reporting accuracy, reducing waiting times and opening new possibilities to empower decision makers.\nAutodidactic, self-motivated, inquisitive, and eager to apply data science techniques to create business value and increase ROI for your company"
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "The Art of Readiable R code\n\n\n\n\n\n\n\nGood Practices\n\n\nCoding Style\n\n\n\n\n\n\n\n\n\n\n\nOct 22, 2023\n\n\nAngel Feliz\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/01-readiable-code/main.html",
    "href": "posts/01-readiable-code/main.html",
    "title": "The Art of Readiable R code",
    "section": "",
    "text": "When we start our journey as programmers it’s normal to get excited by the new possibilities. We get the capacity to do many things that otherwise would be impossible, making projects faster and assuring consistency.\nBut the problems start when you need to modify a script that you wrote 6 months ago. That’s when you find out that you don’t remember why you were applying some specific filters or calculating a value in a odd way.\nAs a Reporting Analyst and I am always creating and changing scripts and after applying the tips provided in The Art of Readable Code by Dustin Boswell and Trevor Foucher I could reduce the time needed to apply changes from 5 to 2 days (60% faster)."
  },
  {
    "objectID": "posts/01-readiable-code/main.html#creating-explicit-names",
    "href": "posts/01-readiable-code/main.html#creating-explicit-names",
    "title": "The Art of Readiable R code",
    "section": "2.1 Creating explicit names",
    "text": "2.1 Creating explicit names\n\n2.1.1 Naming variables\nDefining good variable names is more important than writing a good comment and we should try to give as much context as possible in the variable name. To make this possible:\n\nName based on variable value.\n\nBoolean variables can use words like is, has and should avoid negations. For example: is_integer, has_money and should_end.\nLooping index can have a name followed by the the suffix i. For example: club_i and table_i.\n\nAdd dimensions unit a suffix. For example: price_usd, mass_kg and distance_miles.\nNever change the variable’s value in different sections, instead create a new variable making explicit the change in the name. For example, we can have the variable priceand latter we can create the variable price_discount.\n\n\n\n\n\n\n\nNote\n\n\n\nTo write good variable names might take some iteration and you might need to play devil’s advocate in under to find out a better name than the initial one.\n\n\nCoding Example\nLet’s apply these points to the mtcars.\n\nmtcars_new_names &lt;-\n  c(\"mpg\" = \"miles_per_gallon\",\n    \"cyl\"= \"cylinders_count\",\n    \"disp\" = \"displacement_in3\",\n    \"hp\" = \"power_hp\",\n    \"drat\" = \"rear_axle_ratio\",\n    \"wt\" = \"weight_klb\",\n    \"qsec\" = \"quarter_mile_secs\",\n    \"vs\" = \"engine_is_straight\",\n    \"am\" = \"transmission_is_manual\",\n    \"gear\" = \"gear_count\",\n    \"carb\" = \"carburetor_count\")\n\nmtcars_renamed &lt;- mtcars\nnames(mtcars_renamed) &lt;- mtcars_new_names[names(mtcars)]\n\nstr(mtcars_renamed)\n\n'data.frame':   32 obs. of  11 variables:\n $ miles_per_gallon      : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cylinders_count       : num  6 6 4 6 8 6 8 4 4 6 ...\n $ displacement_in3      : num  160 160 108 258 360 ...\n $ power_hp              : num  110 110 93 110 175 105 245 62 95 123 ...\n $ rear_axle_ratio       : num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ weight_klb            : num  2.62 2.88 2.32 3.21 3.44 ...\n $ quarter_mile_secs     : num  16.5 17 18.6 19.4 17 ...\n $ engine_is_straight    : num  0 0 1 1 0 1 0 1 1 1 ...\n $ transmission_is_manual: num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear_count            : num  4 4 4 3 3 3 3 4 4 4 ...\n $ carburetor_count      : num  4 4 1 1 2 1 4 2 2 4 ...\n\n\n\n\n2.1.2 Defining functions\nCreating explicit functions names can transform a complex process into a simple one.\n\nStart the function with an explicit verb to avoid misunderstandings.\n\n\n\n\nWord\nAlternatives\n\n\n\n\nsend\ndeliver, dispatch, announce, distribute, route\n\n\nfind\nsearch, extract, locate, recover\n\n\nstart\nlaunch, create, begin, open\n\n\nmake\ncreate, set up, build, generate, compose, add, new\n\n\n\n\nThe function name must describe its output.\nA function should do only one thing, otherwise break the functions in more simpler ones to keep the name explicit.\nUse the following words to define range arguments.\n\n\n\n\n\n\n\n\nWord\nUse\n\n\n\n\nmin and max\nUseful to denominate included limits\n\n\nfirst and last\nUseful to denominate exclusive limits\n\n\nbegin and end\nUseful to denominate either inclusive or exclusive limits\n\n\n\nCoding Example\n\nkeep_rows_in_percentile_range &lt;- function(DF,\n                                          var_name,\n                                          min_prob,\n                                          max_prob){\n  \n  if(!is.data.frame(DF)) stop(\"DF should be a data.frame\")\n  \n  values &lt;- DF[[var_name]]\n  if(!is.numeric(values)) stop(\"var_name should be a numeric column of DF\")\n  \n  min_value &lt;- quantile(values, na.rm = TRUE, probs = min_prob)\n  max_value &lt;- quantile(values, na.rm = TRUE, probs = max_prob)\n  \n  value_in_range &lt;- \n    values &gt;= min_value & \n    values &lt;= max_value\n  \n  return(DF[value_in_range, ])\n  \n}"
  },
  {
    "objectID": "posts/01-readiable-code/main.html#commenting-correctly",
    "href": "posts/01-readiable-code/main.html#commenting-correctly",
    "title": "The Art of Readiable R code",
    "section": "2.2 Commenting correctly",
    "text": "2.2 Commenting correctly\nThe first step to have a commented project is to have a README file explaining how the code works in a way that to should be enough to present the project to a new team member, but it is also important to add comments to:\n\nExplain how custom functions behave in several situations with minimal examples.\nExplain the reasons behind the decisions that have been taken related to coding style and business logic, like method and constant selection.\nMake explicit pending problems to solve and the initial idea we have to start the solution.\nAvoid commenting bad names, fix them instead.\nSummarize coding sections with a description faster to read than the original code.\n\n\n\n\n\n\n\nNote\n\n\n\nWriting good comments can be challenging, so you better do it in 3 steps: 1. Write down whatever comment is on your mind 2. Read the comment and see what needs to be improved 3. Make the needed improvements\n\n\nCoding Example\nLet’s comment our custom function to explain each point.\n\n# 1. Behavior\n# This function can filter the values of any  data.frame if the var_name\n# is numeric no matter if the column has missing values as it will omit them\n\n# 2. Reasons behind decisions\n# As we are not expecting to make inferences imputation is not necessary.\n\nkeep_rows_in_percentile_range &lt;- function(DF,\n                                          var_name,\n                                          min_prob,\n                                          max_prob){\n\n  # 5. Reading the code is faster than reading a comment, so we don't need it\n  if(!is.data.frame(DF)) stop(\"DF should be a data.frame\")\n\n  # 2. Reasons behind decisions\n  # We are going to use this vector many times and \n  # saving it as a variable makes the code much easier to read\n  values &lt;- DF[[var_name]]\n  \n  # 5. Reading the code is faster than reading a comment, so we don't need it\n  if(!is.numeric(values)) stop(\"var_name should be a numeric column of DF\")\n  \n  # 2. Reasons behind decisions\n  # Even though a single quantile call could return both values in a vector\n  # it is much simpler to understand if we save each value in a variable\n  min_value &lt;- quantile(values, na.rm = TRUE, probs = min_prob)\n  max_value &lt;- quantile(values, na.rm = TRUE, probs = max_prob)\n  \n  # 4. The boolean test has an explicit name\n  value_in_range &lt;- \n    values &gt;= min_value & \n    values &lt;= max_value\n  \n  return(DF[value_in_range, ])\n  \n}"
  },
  {
    "objectID": "posts/01-readiable-code/main.html#code-style",
    "href": "posts/01-readiable-code/main.html#code-style",
    "title": "The Art of Readiable R code",
    "section": "2.3 Code style",
    "text": "2.3 Code style\nIt is important to apply a coding style that make easy to scan the code before going into detail to certain parts. Some advice to improve code style are:\n\nSimilar code should look similar and be grouped in blocks, it will facilitate finding spelling mistakes and prevent repetitive comments.\n\nWe can see how this tips was applied in the keep_rows_in_percentile_range function.\n\nmin_value &lt;- quantile(values, na.rm = TRUE, probs = min_prob)\nmax_value &lt;- quantile(values, na.rm = TRUE, probs = max_prob)\n\n\nAvoid keeping temporal variables in the global environment .GlobalEnv, instead create a function to make clear the purpose or use pipes (base::|&gt; or magrittr::%&gt;%).\n\nTo ensure this, we created our custom function.\n\nmtcars_renamed |&gt;\n  keep_rows_in_percentile_range(var_name = \"miles_per_gallon\", \n                                min_prob = 0.20,\n                                max_prob = 0.50) |&gt;\n  nrow()\n\n[1] 11\n\n\n\nAvoid writing nested if statements by negating each Boolean test.\n\nIf we hadn’t taken that into consideration our function would be much harder to read.\n\nkeep_rows_in_percentile_range &lt;- function(DF,\n                                          var_name,\n                                          min_prob,\n                                          max_prob){\n  \n  if(is.data.frame(DF)){\n    \n    values &lt;- DF[[var_name]]\n    \n    if(is.numeric(values)){\n      \n      min_value &lt;- quantile(values, na.rm = TRUE, probs = min_prob)\n      max_value &lt;- quantile(values, na.rm = TRUE, probs = max_prob)\n      \n      value_in_range &lt;- \n        values &gt;= min_value & \n        values &lt;= max_value\n      \n      return(DF[value_in_range, ])\n      \n    }else{\n      \n      stop(\"var_name should be a numeric column of DF\")\n      \n    }\n\n  }else{\n    \n    stop(\"DF should be a data.frame\")\n    \n  }\n  \n}\n\n\nBoolean validations should be stored in variables should be stored variables to make explicit what was the test about.\nAlways write constants on the right side of the comparison.\nSimplify Boolean comparisons De Morgan’s Law: ! ( A | B) == !A & !B\n\nIn our custom function min_value and max_value works like constants in comparisons to values\n\nvalue_in_range &lt;- \n  values &gt;= min_value & \n  values &lt;= max_value"
  }
]